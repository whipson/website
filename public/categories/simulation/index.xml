<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simulation on Will Hipson</title>
    <link>/categories/simulation/</link>
    <description>Recent content in Simulation on Will Hipson</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2020</copyright>
    <lastBuildDate>Wed, 31 Jul 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/categories/simulation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Modeling Motivation and Emotion using Feedback Loops</title>
      <link>/post/feedback_loops/feedback_loops/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/feedback_loops/feedback_loops/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;If you’re anything like me, you probably set a lot of goals. Whether it’s to finish a paper by the end of the summer or to spend more time with friends and family, goals are what help motivate us to &lt;em&gt;do something&lt;/em&gt;. Goals are also intimately tied to our feelings. You may have had the experience of falling behind in your goals, which made you upset, but ultimately motivated you to step up your efforts. Conversely, you could be comfortably ahead of your goals and be tempted to coast for a while (much like the Hare in the Tortoise and the Hare who takes a nap when he is far ahead of the Tortoise).&lt;/p&gt;
&lt;p&gt;Charles Carver presented an elegant model of emotion and behavior as intertwined in nested &lt;em&gt;feedback loops&lt;/em&gt;. The idea behind a feedback loop is that you have a system whose output feeds into its input (the typical example being a thermostat). This idea isn’t new (see Powers, 1973), but Carver brilliantly formalized these ideas in this &lt;a href=&#34;https://journals.sagepub.com/doi/abs/10.1177/1754073915590616?journalCode=emra&#34;&gt;2015 paper&lt;/a&gt;, using process diagrams to illustrate his model. In honor of Dr. Carver who passed away this year, I’m bringing his model to life in the form of a simulation.&lt;/p&gt;
&lt;div id=&#34;simple-feedback-loop&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simple Feedback Loop&lt;/h2&gt;
&lt;p&gt;Let’s start with a simple type of feedback loop called a &lt;em&gt;discrepancy-reducing loop&lt;/em&gt;. As we’ll see, the term implies that the object of the loop is to reduce a discrepancy between the system’s current state and an optimal, desired state. Imagine we have a goal of running a marathon and we’re tracking our progress toward that goal. Our desired outcome is to be 100% prepared for the marathon (note that we’re considering the act of running the marathon separate). Every day, we’ll compare our current progress to our desired outcome and this comparison will dictate how much effort we put into training that day. It’s easier to see with a process diagram:&lt;/p&gt;
&lt;div id=&#34;htmlwidget-1&#34; style=&#34;width:672px;height:480px;&#34; class=&#34;grViz html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;diagram&#34;:&#34;\n\ndigraph {\ngraph [overlap = true, fontsize = 20]\nnode [shape = box,\n      fontname = Helvetica]\n\&#34;Desired Progress\&#34;; Behavior; \&#34;Current Progress\&#34;; \&#34;Environment\&#34;\n\nnode [shape = triangle,\n      fixedsize = true,\n      width = 1.8,\n      height = 1.2]\nComparison\n\&#34;Desired Progress\&#34; -&gt; Comparison -&gt; Behavior -&gt; \&#34;Environment\&#34; -&gt; \&#34;Current Progress\&#34; -&gt; Comparison\n}      \n&#34;,&#34;config&#34;:{&#34;engine&#34;:&#34;dot&#34;,&#34;options&#34;:null}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;p&gt;This diagram describes a simple feedback loop whereby a Comparison between Current and Desired Progress affects behavior which, in turn, affects progress. We can emulate this in a simulation using R code.&lt;/p&gt;
&lt;p&gt;Let’s return to our example of wannabe marathon runners. We’ll simulate 10 runners whose marathon preparedness progress starts at 0 and maxes out at 1. The code consists of nested loops. In the first loop (denoted by &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;) we have each of the 10 runners. We initialize their desired condition, which is 1 because they desire to be 100% prepared for the marathon. We then initialize the current condition to 0 to reflect their progress before the simulation starts.&lt;/p&gt;
&lt;p&gt;In the second loop (denoted by &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;) we have each of the 100 days nested within each of the 10 runners. Each day, the runner compares their current progress with their desired condition. The larger this difference, the more &lt;em&gt;effort&lt;/em&gt; they’ll put into training, which increases their chances of making progress. The closer they are to their goal, the less effort they put in. If one’s effort is successful, they make 2.5% progress, if they are not successful, there is a 50/50 chance that progress will decline by 2.5% or stay at it’s current state.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;progress &amp;lt;- data.frame(matrix(nrow = 100, ncol = 10)) # initialize an empty dataframe in which to store progress

set.seed(1678) # for reproducibility

for(i in 1:10){
  desired_condition &amp;lt;- 1 # person desires to complete the task (100% completion)
  current_condition &amp;lt;- 0 # person starts with 0% completion
  for(j in 1:100){ 
    behavior &amp;lt;- desired_condition - current_condition # distance between desire and reality
    environment &amp;lt;- sample(x = c(-.025, 0, .025), size = 1, prob = c(abs(1 - behavior) * .50, abs(1 - behavior) * .50, abs(behavior)))
    current_condition &amp;lt;- current_condition + environment 
    progress[j, i] &amp;lt;- current_condition
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we track progress over each day, here’s what it looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(RColorBrewer)

progress &amp;lt;- progress %&amp;gt;%
  mutate(time = 1:100)

progress_gathered &amp;lt;- gather(progress, key = &amp;quot;person&amp;quot;, value = &amp;quot;progress&amp;quot;, -time)

progress_gathered %&amp;gt;%
  ggplot(aes(x = time, y = progress, group = person)) +
  geom_line(size = 1.25, color = &amp;quot;dodgerblue2&amp;quot;, alpha = .65) +
  labs(x = &amp;quot;Day&amp;quot;,
       y = &amp;quot;Progress toward Goal&amp;quot;,
       title = &amp;quot;Simple Feedback Loop&amp;quot;) +
  theme_minimal(base_size = 24) +
  theme(plot.title = element_text(hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/feedback_loops/Feedback_Loops_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Each line represents a person in the simulation. We see a sharp spike in progress during the first 25 days, then it levels off as the runners approach their goal. Admittedly, the example might not perfectly apply to marathon runners, who may actually see less progress early on when they are in poorer physical shape. A more appropriate example might be weight loss, where people are initially highly motivated to lose weight, but then the person reaches an asymptote and less progress is made.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simple-feedback-with-an-outer-monitoring-loop&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simple Feedback with an Outer Monitoring Loop&lt;/h2&gt;
&lt;p&gt;So, our first example doesn’t do a great job of simulating &lt;em&gt;human&lt;/em&gt; behavior. One major drawback is that progress is only affected by the distance between one’s current state and their desired state. People don’t always use such a wide perspective when contemplating their goals. Recent progress is perhaps more important. In the rhetoric of motivational speakers and self help books: take it one day at a time.&lt;/p&gt;
&lt;p&gt;So now we’ll incorporate an &lt;em&gt;outer loop&lt;/em&gt; that monitors activity in the &lt;em&gt;inner loop&lt;/em&gt; that we built earlier. Importantly though, this monitoring will affect stuff in the inner loop, so it’s not just a passive observer. We’re going to add a &lt;em&gt;rate&lt;/em&gt; parameter that measures the difference between one’s current progress and their progress of the previous day. This will be compared to their desired rate of progress, which we’ll choose to be 5% across the board. For greater clarity, here’s Carver’s take on how the outer loop functions:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“This second loop essentially checks on how well the first one is doing. Thus, the input for the second loop is a representation of the &lt;em&gt;rate of discrepancy reduction in the action system over time&lt;/em&gt;” (emphasis in original).&lt;/p&gt;
&lt;p&gt;— Carver (2015, p. 302)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We’ll use the word &lt;em&gt;approach&lt;/em&gt; to define behavior directed toward a goal. Carver proposed that approach is essentially a &lt;em&gt;discrepancy-reducing&lt;/em&gt; behavior (as we’ll see soon, there’s a counterpart to approach that is instrumental to understanding more complex behaviors). So the higher one’s approach, the greater chances are of success. Diagramatically, it looks like this:&lt;/p&gt;
&lt;div id=&#34;htmlwidget-2&#34; style=&#34;width:672px;height:480px;&#34; class=&#34;grViz html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-2&#34;&gt;{&#34;x&#34;:{&#34;diagram&#34;:&#34;\n\ndigraph {\ngraph [overlap = true, fontsize = 20]\nnode [shape = box,\n      fontname = Helvetica]\n\&#34;Desired Progress\&#34;; Behavior; \&#34;Current Progress\&#34;; \&#34;Environment\&#34;\n\nnode [shape = oval,\n      width = .5]\n\&#34;Desired Rate\&#34;; \&#34;Current Rate\&#34;; \&#34;Change in Rate\&#34;\n\nnode [shape = triangle,\n      fixedsize = true,\n      width = 2.1,\n      height = 1.6]\n\&#34;Comparison A\&#34;; \&#34;Comparison B\&#34;\n\&#34;Desired Progress\&#34; -&gt; \&#34;Comparison A\&#34; -&gt; Behavior -&gt; \&#34;Environment\&#34; -&gt; \&#34;Current Progress\&#34; -&gt; \&#34;Comparison A\&#34;\nBehavior -&gt; \&#34;Current Rate\&#34; -&gt; \&#34;Comparison B\&#34;\n\&#34;Desired Rate\&#34; -&gt; \&#34;Comparison B\&#34;-&gt; \&#34;Change in Rate\&#34; -&gt; \&#34;Environment\&#34; -&gt; \&#34;Current Rate\&#34;\n}      \n&#34;,&#34;config&#34;:{&#34;engine&#34;:&#34;dot&#34;,&#34;options&#34;:null}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;p&gt;Adding another feedback loop complicates things, but what’s important to see is that the organism is comparing both the overall progress and the rate of progress. We can think of it as reflecting on how well it’s doing - not just how far it is from its goal. Now we can add these parameters to the simulation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1272)

progress &amp;lt;- data.frame(matrix(nrow = 100, ncol = 10))

for(i in 1:10){
  desired_condition &amp;lt;- 1 
  desired_rate &amp;lt;- .025 # desirable rate of progress (2.5% per instance)
  current_condition &amp;lt;- 0 
  rate_comparison &amp;lt;- 1 # person starts with rate comparison of 1
  for(j in 1:100){ 
    # Inner Loop
    comparison &amp;lt;- desired_condition - current_condition 
    approach &amp;lt;- comparison * .50 + rate_comparison * .50
    environment &amp;lt;- sample(x = c(-.025, 0, .025), size = 1, prob = c(abs(1 - approach) * .50, abs(1 - approach) * .50, abs(approach)))
    current_condition &amp;lt;- current_condition + environment
    progress[j, i] &amp;lt;- current_condition

    # Outer Loop
    if(j == 1) { 
      current_rate &amp;lt;- 0
    } else {
      current_rate &amp;lt;- progress[j, i] - progress[j - 1, i]
    }
    rate_comparison &amp;lt;- desired_rate - current_rate
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, we can look at progress over time. From now on, I’ll use different colors for each person in the simulation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;progress &amp;lt;- progress %&amp;gt;%
  mutate(time = 1:100)

progress_gathered &amp;lt;- gather(progress, key = &amp;quot;person&amp;quot;, value = &amp;quot;progress&amp;quot;, -time)

progress_gathered %&amp;gt;%
  ggplot(aes(x = time, y = progress, color = person)) +
  geom_line(size = 1.25, alpha = .65) +
  scale_color_brewer(palette = &amp;quot;Spectral&amp;quot;) +
  labs(x = &amp;quot;Day&amp;quot;,
       y = &amp;quot;Progress toward Goal&amp;quot;,
       title = &amp;quot;Feedback Loop with Monitoring&amp;quot;) +
  theme_minimal(base_size = 24) +
  theme(plot.title = element_text(hjust = .5),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/feedback_loops/Feedback_Loops_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Compared to before, the rate of progress is slower on average. There is also more variation between people, as some achieve 50% progress and others are not much farther from where they started. What’s happening is &lt;em&gt;approach&lt;/em&gt; behavior increases when the rate of progress is less than desirable. However, when the rate of progress is greater than desirable, approach behavior decreases. This leads to a fluctuating pattern of ups and downs, similar to what occurs in people who diet.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;feedback-loops-and-mood&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Feedback Loops and Mood&lt;/h2&gt;
&lt;p&gt;In the last example, we used an &lt;em&gt;Outer Loop&lt;/em&gt; to monitor the rate of progress in the system. We can think of &lt;em&gt;mood&lt;/em&gt; as a byproduct of this outer loop - our subjective feeling about our progress. When we make progress toward our goals we feel happy and we relax. When we fall behind in our goals we feel upset and increase our efforts.&lt;/p&gt;
&lt;p&gt;Now we’ll add to the outer loop a variable called &lt;em&gt;affect&lt;/em&gt;, which is just the psychologist’s way of saying ‘mood’. Unlike my previous emotion simulations, we’ll stick to only one dimension of affect: valence (pleasant vs. unpleasant). High valence means you’re feeling happy, while low valence could mean sadness or anger.&lt;/p&gt;
&lt;p&gt;Affect will be neutral for the first 5 days. After that, affect will be a function of &lt;em&gt;autocorrelation&lt;/em&gt;, one’s current rate of progress, and their overall &lt;em&gt;progress slope&lt;/em&gt; (i.e., extant rate of progress). The progress slope forecasts one’s overall rate of progress based on how well they’ve done so far. In this way, if someone is progressing at a slow rate, they will feel more negative.&lt;/p&gt;
&lt;p&gt;We won’t bother with the diagrams from hereout because they become needlessly complicated. What’s important to know is that affect emerges as a byproduct of multiple comparisons between progress and desired progress. Here’s the revised R code for the simulation with affect.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(12581)

progress &amp;lt;- data.frame(matrix(nrow = 100, ncol = 10))
affect &amp;lt;- data.frame(matrix(nrow = 100, ncol = 10))

for(i in 1:10){
  desired_condition &amp;lt;- 1
  desired_rate &amp;lt;- .025
  current_condition &amp;lt;- 0
  rate_comparison &amp;lt;- 1
  valence_attractor &amp;lt;- rnorm(n = 1, mean = 0.3, sd = .01) # average emotional state
  for(j in 1:100){ 
    # Inner Loop
    comparison &amp;lt;- desired_condition - current_condition
    approach &amp;lt;- comparison * .50 + rate_comparison * .50
    environment &amp;lt;- sample(x = c(-.025, 0, .025), size = 1, prob = c(abs(1 - approach) * .50, abs(1 - approach) * .50, abs(approach)))
    current_condition &amp;lt;- current_condition + environment
    progress[j, i] &amp;lt;- current_condition

    # Outer Loop
    if(j == 1) {
      current_rate &amp;lt;- 0
    } else {
      current_rate &amp;lt;- progress[j, i] - progress[j - 1, i]
    }
    rate_comparison &amp;lt;- desired_rate - current_rate
    progress_slope &amp;lt;- progress[j, i] - progress[1, i]/(j - 1)
    if(j &amp;lt;= 5) {
      affect[j, i] &amp;lt;- valence_attractor + rnorm(n = 1, mean = valence_attractor, sd = 1) * .01
    } else {
      affect[j, i] &amp;lt;- affect[j - 1, i] * .25 + progress_slope * .50 + (1 - rate_comparison) * .24 + rnorm(n = 1, mean = valence_attractor, sd = 1) * .01
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have progress and affect, let’s look at them together. We can add two plots together using the &lt;em&gt;ggpubr&lt;/em&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggpubr)

progress &amp;lt;- progress %&amp;gt;%
  mutate(time = 1:100)

progress_gathered &amp;lt;- gather(progress, key = &amp;quot;person&amp;quot;, value = &amp;quot;progress&amp;quot;, -time)

progress_plot &amp;lt;- progress_gathered %&amp;gt;%
  ggplot(aes(x = time, y = progress, color = person)) +
  geom_line(size = 1.25, alpha = .65) +
  scale_color_brewer(palette = &amp;quot;Spectral&amp;quot;) +
  labs(x = &amp;quot;Day&amp;quot;,
       y = &amp;quot;Progress toward Goal&amp;quot;,
       title = &amp;quot;Progress&amp;quot;) +
  theme_minimal(base_size = 20) +
  theme(legend.position = &amp;quot;none&amp;quot;,
        plot.title = element_text(hjust = .5),
        axis.title.y = element_text(size = 14)) 

affect &amp;lt;- affect %&amp;gt;%
  mutate(time = 1:100)

affect_gathered &amp;lt;- gather(affect, key = &amp;quot;person&amp;quot;, value = &amp;quot;affect&amp;quot;, -time)

affect_plot &amp;lt;- affect_gathered %&amp;gt;%
  ggplot(aes(x = time, y = affect, color = person)) +
  geom_line(size = 1.25, alpha = .65) +
  scale_color_brewer(palette = &amp;quot;Spectral&amp;quot;) +
  labs(x = &amp;quot;Day&amp;quot;,
       y = &amp;quot;Affect (higher = happier)&amp;quot;,
       title = &amp;quot;Affect&amp;quot;) +
  theme_minimal(base_size = 20) +
  theme(legend.position = &amp;quot;none&amp;quot;,
        plot.title = element_text(hjust = .5),
        axis.title.y = element_text(size = 14))

plots1 &amp;lt;- ggarrange(progress_plot, affect_plot, nrow = 2)
plots1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/feedback_loops/Feedback_Loops_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Affect is largely in-step with progress. Again, this is reflecting that people feel happier when they are making progress toward their goals. But we know that our mood is more complicated than this. Say we’re competing against others in a diet challenge to see who can lose the most weight over 100 days. If we see that we’re way behind in our progress, with no hope of catching up, we may throw in the towel and quit trying altogether. Indeed, humans are highly attuned to &lt;em&gt;social comparisons&lt;/em&gt;, especially in competitive environments.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;feedback-loops-mood-and-social-comparison&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Feedback Loops, Mood, and Social Comparison&lt;/h2&gt;
&lt;p&gt;Our last and most complex simulation will take into account how people’s behavior toward a goal changes when they receive social comparison feedback. If you have no chance winning the competition, why expend effort at all? Things get even more complicated from here, as we now have to create dependence among organisms in the simulation. Before, everyone’s performance was independent; now each new person who enters the simulation becomes aware of their performance relative to their peers’.&lt;/p&gt;
&lt;p&gt;We add two new parameters. The first, &lt;em&gt;average progress rate&lt;/em&gt;, is the average slope of prior runs in the simulation (akin to watching your competitor’s performance and then yourself performing). Indeed, these are not run in parallel, so the first simulated person has no insight into the performance of others, while the second person is only aware of how well the first person did, and so on. The second parameter is &lt;em&gt;relative standing&lt;/em&gt; and it is simply the difference between one’s current progress rate and the average progress rate. In general, as relative standing increases (as the distance becomes larger) avoidance behavior increases. This works in two ways: (1) performance exceeds that of others and effort goes down (e.g., coasting) or (2) performance pales relative to others and hopelessness ensues. To model this, at the halfway point, if one’s relative standing is 35% less than the average, that person will effectively give up, saving themselves from severe upset. Indeed, some have suggested that this is an adaptive response because it allows people to reprioritize their efforts (Simon, 1967).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1249)

progress &amp;lt;- data.frame(matrix(nrow = 100, ncol = 10))
affect &amp;lt;- data.frame(matrix(nrow = 100, ncol = 10))

for(i in 1:10){
  desired_condition &amp;lt;- 1
  desired_rate &amp;lt;- .050
  current_condition &amp;lt;- 0
  rate_comparison &amp;lt;- 1
  valence_attractor &amp;lt;- rnorm(n = 1, mean = 0.3, sd = .01)
  average_progress_rate &amp;lt;- 0
  relative_standing &amp;lt;- 1
  for(j in 1:100){ 
    # Inner Loop
    comparison &amp;lt;- desired_condition - current_condition
    approach &amp;lt;- (abs(comparison * .50 + rate_comparison * .50))/(abs(relative_standing) + (comparison * .75 + abs(rate_comparison) * .25))
    avoidance &amp;lt;- (abs(relative_standing))/(abs(relative_standing) + (comparison * .75 + abs(rate_comparison) * .25))
    environment &amp;lt;- sample(x = c(-.025, 0, .025), size = 1, prob = c(avoidance * .50, avoidance * .50, approach))
    current_condition &amp;lt;- current_condition + environment 
    progress[j, i] &amp;lt;- ifelse(current_condition &amp;lt;= 0, 0, current_condition)

    # Outer Loop
    if(j == 1) {
      current_rate &amp;lt;- 0
    } else {
      current_rate &amp;lt;- progress[j, i] - progress[j - 1, i]
      progress_slope &amp;lt;- progress[j, i] - progress[1, i]/(j - 1)
      relative_standing &amp;lt;- progress_slope - average_progress_rate
    }
    rate_comparison &amp;lt;- desired_rate - current_rate
    if(j &amp;lt;= 5) {
      affect[j, i] &amp;lt;- valence_attractor + rnorm(n = 1, mean = valence_attractor, sd = 1) * .01
    } else if (j &amp;gt;= 50 &amp;amp;&amp;amp; relative_standing &amp;lt;= .35) {
      desired_condition &amp;lt;- current_condition
      rate_comparison &amp;lt;- 0
      affect[j, i] &amp;lt;- affect[j - 1, i] * .99 + rnorm(n = 1, mean = valence_attractor, sd = 1) * .01
    } else {
      affect[j, i] &amp;lt;- affect[j - 1, i] * .25 + progress_slope * .50 + relative_standing * .24 + rnorm(n = 1, mean = valence_attractor, sd = 1) * .01
    }
  }
  if(i &amp;gt; 1){
    average_progress_rate &amp;lt;- mean(t(progress[100, (i - 1):1]))
  } else {
    average_progress_rate &amp;lt;- 0
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the code above, we can enter it into the next code chunk to get the plots. Again, we’ll plot them together to compare progress and affect.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;progress &amp;lt;- progress %&amp;gt;%
  mutate(time = 1:100)

progress_gathered &amp;lt;- gather(progress, key = &amp;quot;person&amp;quot;, value = &amp;quot;progress&amp;quot;, -time)

progress_plot2 &amp;lt;- progress_gathered %&amp;gt;%
  ggplot(aes(x = time, y = progress, color = person)) +
  geom_line(size = 1.25, alpha = .65) +
  scale_color_brewer(palette = &amp;quot;Spectral&amp;quot;) +
  labs(x = &amp;quot;Day&amp;quot;,
       y = &amp;quot;Progress toward Goal&amp;quot;,
       title = &amp;quot;Progress&amp;quot;) +
  theme_minimal(base_size = 20) +
  theme(legend.position = &amp;quot;none&amp;quot;,
        plot.title = element_text(hjust = .5),
        axis.title.y = element_text(size = 14)) 

affect &amp;lt;- affect %&amp;gt;%
  mutate(time = 1:100)

affect_gathered &amp;lt;- gather(affect, key = &amp;quot;person&amp;quot;, value = &amp;quot;affect&amp;quot;, -time)

affect_plot2 &amp;lt;- affect_gathered %&amp;gt;%
  ggplot(aes(x = time, y = affect, color = person)) +
  geom_line(size = 1.25, alpha = .65) +
  scale_color_brewer(palette = &amp;quot;Spectral&amp;quot;) +
    labs(x = &amp;quot;Day&amp;quot;,
       y = &amp;quot;Affect (higher = happier)&amp;quot;,
       title = &amp;quot;Affect&amp;quot;) +
  theme_minimal(base_size = 20) +
  theme(legend.position = &amp;quot;none&amp;quot;,
        plot.title = element_text(hjust = .5),
        axis.title.y = element_text(size = 14))

plots2 &amp;lt;- ggarrange(progress_plot2, affect_plot2, nrow = 2)
plots2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/feedback_loops/Feedback_Loops_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can clearly see where a few competitors bailed out and their progress dropped to zero. This is because their relative standing was weak and they relinquished. Importantly though, they didn’t suffer too heavy a blow in affect, and this is because they no longer valued progress toward this goal.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We set out to show that motivation and emotion can be simulated using fairly simple feedback loops. Of course, human behavior is exceedingly more complicated, but we can learn a lot by simulating ersatz humans with only a handful of parameters. As I continue to work toward my PhD, my appreciation for Carver’s computational models only grows stronger. My goal is to see psychological research and computer simulations partake in their own form of feedback loop, where knowledge from the former feeds into our construction of the latter.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://journals.sagepub.com/doi/abs/10.1177/1754073915590616?journalCode=emra&#34;&gt;Carver, C. S. (2015). Control processes, priority management, and affective dynamics. &lt;em&gt;Emotion Review, 7&lt;/em&gt;, 301-307.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Powers, W. T. (1973). &lt;em&gt;Behavior: The control of perception.&lt;/em&gt; Chicago, IL: Aldine.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://psycnet.apa.org/record/1967-03946-001&#34;&gt;Simon, H. A. (1967). Motivational and emotional controls of cognition. &lt;em&gt;Psychology Review, 74&lt;/em&gt;, 29-39.&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
      
            <category>R</category>
      
            <category>Emotion Dynamics</category>
      
            <category>Simulation</category>
      
            <category>Feedback Loops</category>
      
      
            <category>R</category>
      
            <category>Emotion Dynamics</category>
      
            <category>Simulation</category>
      
            <category>Feedback Loops</category>
      
    </item>
    
    <item>
      <title>A Model and Simulation of Emotion Dynamics</title>
      <link>/post/emotion-simulation1/emotion_sim/</link>
      <pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/emotion-simulation1/emotion_sim/</guid>
      <description>


&lt;p&gt;Emotion dynamics is the study of how emotions change over time. Sometimes our feelings are quite stable, but other times capricious. Measuring and predicting these patterns for different people is somewhat of a Holy Grail for emotion researchers. In particular, some researchers are aspiring to discover mathematical laws that capture the complexity of our inner emotional experiences - much like physicists divining the laws that govern objects in the natural environment. These discoveries would revolutionize our understanding of our everyday feelings and when our emotions can go awry.&lt;/p&gt;
&lt;p&gt;This series of blog posts, which I kicked off earlier this month with a &lt;a href=&#34;https://willhipson.netlify.com/post/basketball_sim/basketball_sim/&#34;&gt;simulation of emotions during basketball games&lt;/a&gt;, is inspired by researchers like &lt;a href=&#34;https://ppw.kuleuven.be/okp/people/Peter_Kuppens/&#34;&gt;Peter Kuppens&lt;/a&gt; and &lt;a href=&#34;https://www.queensu.ca/psychology/people/faculty/tom-hollenstein&#34;&gt;Tom Hollenstein&lt;/a&gt; (to name a few) who have collected and analyzed reams of intensive self-reports on people’s feelings from one moment to the next. My approach is to reverse engineer these insights and generate models that &lt;em&gt;simulate&lt;/em&gt; emotions evolving over time - like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-1-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;div id=&#34;affective-state-space&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Affective State Space&lt;/h2&gt;
&lt;p&gt;We start with the affective state space - the theoretical landscape on which our conscious feelings roam free. This space is represented as &lt;em&gt;two-dimensional&lt;/em&gt;, although we acknowledge that this fails to capture all aspects of conscious feeling. The first dimension, represented along the x-axis, is &lt;em&gt;valence&lt;/em&gt; and this refers to how unpleasant vs. pleasant we feel. The second dimension, represented along the y-axis, is &lt;em&gt;arousal&lt;/em&gt;. Somewhat less intuitive, arousal refers to how deactivated/sluggish/sleepy vs. activated/energized/awake we feel. At any time, our emotional state can be defined in terms of valence and arousal. So if you’re feeling stressed you would be low in valence and high in arousal. Let’s say you’re serene and calm, then you would be high in valence and low in arousal. Most of the time, we feel moderately high valence and moderate arousal (i.e., content), but if you’re the type of person who is chronically stressed, this would be different.&lt;/p&gt;
&lt;p&gt;This is all well and good when we think about how we’re feeling right now, but it’s also worth considering how our emotions are changing. On a regular day, our emotions undergo minor fluctuations - sometimes in response to minor hassles or victories, and sometimes for no discernible reason. In this small paragraph, I’ve laid out a number of parameters, all of which vary between different people:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Attractor&lt;/strong&gt;: Our typical emotional state. At any given moment, our feelings are pulled toward this state. Some people tend to be happier, whereas others are less happy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stability&lt;/strong&gt;: How emotionally stable one is. Some people are more emotionally stable than others. Even in the face of adversity, an emotionally stable person keeps their cool.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dispersion&lt;/strong&gt;: The range of our emotional landscape. Some people experience intense highs and lows, whereas others persist somewhere in the middle.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We’ll keep all of this in mind for the simulation. We’ll start with a fairly simple simulation with 100 hypothetical people. We’ll need the following packages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(psych)
library(tidyverse)
library(sn)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we’ll create a function that performs the simulation. Note that each person &lt;em&gt;i&lt;/em&gt; has their own attractor, recovery rate, stability, and dispersion. For now we’ll just model random fluctuations in emotions, a sort of Brownian motion. You can imagine our little &lt;strong&gt;simulatons&lt;/strong&gt; (fun name for the hypothetical people in the simulation) sitting around on an average day doing nothing in particular.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simulate_affect &amp;lt;- function(n = 2, time = 250, negative_event_time = NULL) {
  dt &amp;lt;- data.frame(matrix(nrow = time, ncol = 1))
  colnames(dt) &amp;lt;- &amp;quot;time&amp;quot;
  dt$time &amp;lt;- 1:time
  
  valence &amp;lt;- data.frame(matrix(nrow = time, ncol = 0))
  arousal &amp;lt;- data.frame(matrix(nrow = time, ncol = 0))
  
  for(i in 1:n) {
    attractor_v &amp;lt;- rnorm(1, mean = 3.35, sd = .75)
    instability_v &amp;lt;- sample(3:12, 1, replace = TRUE, prob = c(.18, .22, .18, .15, .8, .6, .5, .4, .2, .1))
    dispersion_v &amp;lt;- abs(rsn(1, xi = .15, omega = .02, alpha = -6) * instability_v) #rsn simulates a skewed distribution.
    if(!is.null(negative_event_time)) {
      recovery_rate &amp;lt;- sample(1:50, 1, replace = TRUE) + negative_event_time
      negative_event &amp;lt;- (dt$time %in% negative_event_time:recovery_rate) * seq.int(50, 1, -1)
    }
    else {
      negative_event &amp;lt;- 0
    }
    valence[[i]] &amp;lt;- ksmooth(x = dt$time,
                            y = (negative_event * -.10) + arima.sim(list(order = c(1, 0, 0),
                                               ar = .50),
                                          n = time),
                            bandwidth = time/instability_v, kernel = &amp;quot;normal&amp;quot;)$y * dispersion_v + attractor_v 

#instability is modelled in the bandwidth term of ksmooth, such that higher instability results in higher bandwidth (greater fluctuation). 
#dispersion scales the white noise (arima) parameter, such that there are higher peaks and troughs at higher dispersion.
    
    attractor_a &amp;lt;- rnorm(1, mean = .50, sd = .75) + sqrt(instability_v) #arousal attractor is dependent on instability. This is because high instability is associated with higher arousal states.
    instability_a &amp;lt;- instability_v + sample(-1:1, 1, replace = TRUE)
    dispersion_a &amp;lt;- abs(rsn(1, xi = .15, omega = .02, alpha = -6) * instability_a)
    arousal[[i]] &amp;lt;- ksmooth(x = dt$time,
                            y = (negative_event * .075) + arima.sim(list(order = c(1, 0, 0),
                                               ar = .50),
                                          n = time),
                            bandwidth = time/instability_a, kernel = &amp;quot;normal&amp;quot;)$y * dispersion_a + attractor_a
  }
  
  valence[valence &amp;gt; 6] &amp;lt;- 6
  valence[valence &amp;lt; 0] &amp;lt;- 0
  arousal[arousal &amp;gt; 6] &amp;lt;- 6
  arousal[arousal &amp;lt; 0] &amp;lt;- 0
  
  colnames(valence) &amp;lt;- paste0(&amp;quot;valence_&amp;quot;, 1:n)
  colnames(arousal) &amp;lt;- paste0(&amp;quot;arousal_&amp;quot;, 1:n)
  
  dt &amp;lt;- cbind(dt, valence, arousal)
  
  return(dt)
}

set.seed(190625)

emotions &amp;lt;- simulate_affect(n = 100, time = 300)

emotions %&amp;gt;%
  select(valence_1, arousal_1) %&amp;gt;%
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   valence_1 arousal_1
## 1  1.328024  5.380643
## 2  1.365657  5.385633
## 3  1.401849  5.390470
## 4  1.436284  5.395051
## 5  1.468765  5.399162
## 6  1.499062  5.402752&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we see the first six rows for participant 1’s valence and arousal. But if we want to plot these across multiple simulatons, we need to wrangle the data into long form. We’ll also compute some measures of within-person deviation. The Root Mean Square Successive Difference (RMSSD) takes into account gradual shifts in the mean. Those who are more emotionally unstable will have a higher RMSSD. For two dimensions (valence and arousal) we’ll just compute the mean RMSSD.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emotions_long &amp;lt;- emotions %&amp;gt;%
  gather(key, value, -time) %&amp;gt;%
  separate(key, into = c(&amp;quot;dimension&amp;quot;, &amp;quot;person&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  spread(dimension, value) %&amp;gt;%
  group_by(person) %&amp;gt;%
  mutate(rmssd_v = rmssd(valence),
         rmssd_a = rmssd(arousal),
         rmssd_total = mean(rmssd_v + rmssd_a)) %&amp;gt;%
  ungroup()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s see what this looks like for valence and arousal individually.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emotions_long %&amp;gt;%
  ggplot(aes(x = time, y = valence, group = person, color = rmssd_v)) +
  geom_line(size = .75, alpha = .75) +
  scale_color_gradient2(low = &amp;quot;black&amp;quot;, mid = &amp;quot;grey&amp;quot;, high = &amp;quot;red&amp;quot;, midpoint = median(emotions_long$rmssd_v)) +
  labs(x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Valence&amp;quot;,
       color = &amp;quot;Instability&amp;quot;,
       title = &amp;quot;Simulated Valence Scores over Time for 100 People&amp;quot;) +
  theme_minimal(base_size = 16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emotions_long %&amp;gt;%
  ggplot(aes(x = time, y = arousal, group = person, color = rmssd_a)) +
  geom_line(size = .75, alpha = .75) +
  scale_color_gradient2(low = &amp;quot;black&amp;quot;, mid = &amp;quot;grey&amp;quot;, high = &amp;quot;red&amp;quot;, midpoint = median(emotions_long$rmssd_a)) +
  labs(x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Arousal&amp;quot;,
       color = &amp;quot;Instability&amp;quot;,
       title = &amp;quot;Simulated Arousal Scores over Time for 100 People&amp;quot;) +
  theme_minimal(base_size = 16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-5-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see that some lines are fairly flat and others fluctuate more widely. More importantly, most people are somewhere in the middle.&lt;/p&gt;
&lt;p&gt;We can get a sense of one simulated person’s affective state space as well. The goal here is to mimic the kinds of models shown in &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/20853980&#34;&gt;Kuppens, Oravecz, and Tuerlinckx (2010)&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emotions_long %&amp;gt;%
  filter(person %in% sample(1:100, 6, replace = FALSE)) %&amp;gt;%
  ggplot(aes(x = valence, y = arousal, group = person)) +
  geom_path(size = .75) + 
  scale_x_continuous(limits = c(0, 6)) +
  scale_y_continuous(limits = c(0, 6)) +
  labs(x = &amp;quot;Valence&amp;quot;,
       y = &amp;quot;Arousal&amp;quot;,
       title = &amp;quot;Affective State Space for Six Randomly Simulated People&amp;quot;) +
  facet_wrap(~person) +
  theme_minimal(base_size = 18) +
  theme(plot.title = element_text(size = 18, hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;animating-the-affective-state-space&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Animating the Affective State Space&lt;/h2&gt;
&lt;p&gt;To really appreciate what’s going on, we need to animate this over time. I’ll add some labels to the affective state space so that it’s easier to interpret what one might be feeling at that time. I’ll also add color to show which individuals are more unstable according to RMSSD.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gganimate)

p &amp;lt;- emotions_long %&amp;gt;%
  ggplot(aes(x = valence, y = arousal, color = rmssd_total)) +
  annotate(&amp;quot;text&amp;quot;, x = c(1.5, 4.5, 1.5, 4.5), y = c(1.5, 1.5, 4.5, 4.5), label = c(&amp;quot;Gloomy&amp;quot;, &amp;quot;Calm&amp;quot;, &amp;quot;Anxious&amp;quot;, &amp;quot;Happy&amp;quot;),
           size = 10, alpha = .50) + 
  annotate(&amp;quot;rect&amp;quot;, xmin = 0, xmax = 3, ymin = 0, ymax = 3, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 3, xmax = 6, ymin = 0, ymax = 3, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 0, xmax = 3, ymin = 3, ymax = 6, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 3, xmax = 6, ymin = 3, ymax = 6, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  geom_point(size = 3.5) +
  scale_color_gradient2(low = &amp;quot;black&amp;quot;, mid = &amp;quot;grey&amp;quot;, high = &amp;quot;red&amp;quot;, midpoint = median(emotions_long$rmssd_total)) +
  scale_x_continuous(limits = c(0, 6)) +
  scale_y_continuous(limits = c(0, 6)) +
  labs(x = &amp;quot;Valence&amp;quot;,
       y = &amp;quot;Arousal&amp;quot;,
       color = &amp;quot;Instability&amp;quot;,
       title = &amp;#39;Time: {round(frame_time)}&amp;#39;) +
  transition_time(time) +
  theme_minimal(base_size = 18)

ani_p &amp;lt;- animate(p, nframes = 320, end_pause = 20, fps = 16, width = 550, height = 500)

ani_p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-7-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;theres-a-storm-coming&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;There’s a Storm Coming…&lt;/h2&gt;
&lt;p&gt;Our simulation does a pretty good job at emulating the natural ebb and flow of emotions, but we know that emotions can be far more volatile. Let’s subject our simulation to a negative event. Perhaps all 100 &lt;strong&gt;simulatons&lt;/strong&gt; co-authored a paper that just got rejected. In the function &lt;em&gt;simulate_affect&lt;/em&gt;, there’s an optional argument &lt;em&gt;negative_event_time&lt;/em&gt; that causes a negative event to occur at the specified time. For this, we need to consider one more emotion dynamics parameter:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Recovery rate&lt;/strong&gt;: How quickly one recovers from an emotional event. If something bad happens, how long does it take to return to the attractor. You can see how I’ve modelled this parameter in the function above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So we’ll run the simulation with a negative event arising at &lt;em&gt;t&lt;/em&gt; = 150. The negative event will cause a downward spike in valence and an upward spike in arousal.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emotions_event &amp;lt;- simulate_affect(n = 100, time = 300, negative_event_time = 150)

emotions_event_long &amp;lt;- emotions_event %&amp;gt;%
  gather(key, value, -time) %&amp;gt;%
  separate(key, into = c(&amp;quot;dimension&amp;quot;, &amp;quot;person&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  spread(dimension, value) %&amp;gt;%
  group_by(person) %&amp;gt;%
  mutate(rmssd_v = rmssd(valence),
         rmssd_a = rmssd(arousal),
         rmssd_total = mean(rmssd_v + rmssd_a)) %&amp;gt;%
  ungroup()

emotions_event_long %&amp;gt;%
  ggplot(aes(x = time, y = valence, group = person, color = rmssd_v)) +
  geom_line(size = .75, alpha = .75) +
  scale_color_gradient2(low = &amp;quot;black&amp;quot;, mid = &amp;quot;grey&amp;quot;, high = &amp;quot;red&amp;quot;, midpoint = median(emotions_event_long$rmssd_v)) +
  labs(x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Valence&amp;quot;,
       color = &amp;quot;Instability&amp;quot;,
       title = &amp;quot;Simulated Valence Scores over Time for 100 People&amp;quot;) +
  theme_minimal(base_size = 16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emotions_event_long %&amp;gt;%
  ggplot(aes(x = time, y = arousal, group = person, color = rmssd_a)) +
  geom_line(size = .75, alpha = .75) +
  scale_color_gradient2(low = &amp;quot;black&amp;quot;, mid = &amp;quot;grey&amp;quot;, high = &amp;quot;red&amp;quot;, midpoint = median(emotions_event_long$rmssd_a)) +
  labs(x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Arousal&amp;quot;,
       color = &amp;quot;Instability&amp;quot;,
       title = &amp;quot;Simulated Arousal Scores over Time for 100 People&amp;quot;) +
  theme_minimal(base_size = 16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-8-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s pretty clear that something bad happened. Of course, some of our &lt;strong&gt;simulatons&lt;/strong&gt; are unflappable, but most experienced a drop in valence and spike in arousal that we might identify as anxiety. Again, let’s visualize this evolving over time. Pay close attention to when the timer hits 150.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p2 &amp;lt;- emotions_event_long %&amp;gt;%
  ggplot(aes(x = valence, y = arousal, color = rmssd_total)) +
  annotate(&amp;quot;text&amp;quot;, x = c(1.5, 4.5, 1.5, 4.5), y = c(1.5, 1.5, 4.5, 4.5), label = c(&amp;quot;Gloomy&amp;quot;, &amp;quot;Calm&amp;quot;, &amp;quot;Anxious&amp;quot;, &amp;quot;Happy&amp;quot;),
           size = 10, alpha = .50) + 
  annotate(&amp;quot;rect&amp;quot;, xmin = 0, xmax = 3, ymin = 0, ymax = 3, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 3, xmax = 6, ymin = 0, ymax = 3, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 0, xmax = 3, ymin = 3, ymax = 6, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 3, xmax = 6, ymin = 3, ymax = 6, alpha = 0.25, color = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;) +
  geom_point(size = 3.5) +
  scale_color_gradient2(low = &amp;quot;black&amp;quot;, mid = &amp;quot;grey&amp;quot;, high = &amp;quot;red&amp;quot;, midpoint = median(emotions_event_long$rmssd_total)) +
  scale_x_continuous(limits = c(0, 6)) +
  scale_y_continuous(limits = c(0, 6)) +
  labs(x = &amp;quot;Valence&amp;quot;,
       y = &amp;quot;Arousal&amp;quot;,
       color = &amp;quot;Instability&amp;quot;,
       title = &amp;#39;Time: {round(frame_time)}&amp;#39;) +
  transition_time(time) +
  theme_minimal(base_size = 18)

ani_p2 &amp;lt;- animate(p2, nframes = 320, end_pause = 20, fps = 16, width = 550, height = 500)

ani_p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/emotion-simulation1/Emotion_Simulation_files/figure-html/unnamed-chunk-9-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;The overall picture is that some are more emotionally resilient than others. As of now, all the &lt;strong&gt;simulatons&lt;/strong&gt; return to their baseline attractor, but we would realistically expect some to stay stressed or gloomy following bad news. In the coming months I’ll be looking into how to incorporate emotion regulation into the simulation. For example, maybe some of the &lt;strong&gt;simulatons&lt;/strong&gt; use better coping strategies than others? I’m also interested in incorporating &lt;em&gt;appraisal&lt;/em&gt; mechanisms that allow for different reactions depending on the type of emotional stimulus.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/20853980&#34;&gt;Kuppens, P., Oravecz, Z., &amp;amp; Tuerlinckx, F. (2010). Feelings change: Accounting for individual differences in the temporal dynamics of affect. &lt;em&gt;Journal of Personality and Social Psychology, 99&lt;/em&gt;, 1042-1060&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
      
            <category>R</category>
      
            <category>Emotion Dynamics</category>
      
            <category>Simulation</category>
      
      
            <category>R</category>
      
            <category>Emotion Dynamics</category>
      
            <category>Simulation</category>
      
    </item>
    
    <item>
      <title>Simulating Emotions during a Basketball Game - Just a Feeling in the Crowd</title>
      <link>/post/basketball_sim/basketball_sim/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/basketball_sim/basketball_sim/</guid>
      <description>


&lt;p&gt;Sporting events host witness to a wide range of human emotion. The emotional ups and downs are especially clear among invested fans. Fans experience the joy and excitement of a triumphant comeback, or the anxiety and disappointment of a loss. It is particularly interesting to see how emotions differ from two opposing fan groups watching the same match.&lt;/p&gt;
&lt;p&gt;I decided to perform some simulations on how a crowd of fans would react during a basketball game. Why basketball? Two reasons: First is the frequency of scoring (more baskets = more &lt;em&gt;reactive&lt;/em&gt; simulation), and second is that the NBA finals are in swing at time of writing.&lt;/p&gt;
&lt;p&gt;Below I’ve described the parameters of the simulation in detail and provided reproducible code for all examples, but here’s the quick and dirty. I’m simulating fans’ happiness and nerves (valence and arousal). Happiness reflects baskets scored (up for team basket and down for enemy basket) and overall team performance. Nerves reflects baskets scored, time remaining in game, and the difference between score (higher for closer game). There are other parameters involved that are described in more detail below.&lt;/p&gt;
&lt;p&gt;Let’s run the simulation! I’m simulating a short game that’s about 16 minutes long, but the simulation is sped up. There are 25 fans per team with each dot representing a fan. Blue dots root for the blue team and red dots for red. In this game, blue starts ahead, but red makes a rallying comeback.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/basketball_sim/Basketball_Simulation_files/figure-html/unnamed-chunk-1-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;What are we seeing here? As the game progresses, fans move into different emotional states. I’ve used the terms &lt;em&gt;content&lt;/em&gt;, &lt;em&gt;disappointed&lt;/em&gt;, &lt;em&gt;nervous&lt;/em&gt;, and &lt;em&gt;excited&lt;/em&gt; as helpful placeholders, but we should think of these in terms of varying along dimensions of &lt;em&gt;valence&lt;/em&gt; (e.g., happiness) and &lt;em&gt;arousal&lt;/em&gt; (e.g., nerves, excitedness). For example, when their team is doing well, fans are happier, but they’re only excited when the score is close. For each basket, there’s a brief spike in arousal and happiness. As the game draws closer to an end, fans get more excited/anxious, especially if the score is close.&lt;/p&gt;
&lt;p&gt;So how would this play out if one team decimated the other? Let’s give the red team a slight edge over blue:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/basketball_sim/Basketball_Simulation_files/figure-html/unnamed-chunk-2-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;Notice how ‘excited’ becomes ‘content’ and ‘nervous’ turns to ‘disappointment’ because the difference becomes insurmountable for the blue team. We can plug in any numbers for this function to produce different results. However, the algorithm is highly sensitive to small changes in scoring chance because this is calculated for every &lt;em&gt;second&lt;/em&gt; of the game.&lt;/p&gt;
&lt;div id=&#34;going-behind-the-simulation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Going Behind the Simulation&lt;/h2&gt;
&lt;p&gt;Skip this if you have no interest in the psychology of emotions. What I’m striving to simulate are the laws of emotion dynamics (Kuppens &amp;amp; Verduyn, 2017). Emotions change from moment to moment, but there’s also some stability from one moment to the next. Apart from when a basket is scored, most fans cluster around a particular state (this is called an &lt;em&gt;attractor state&lt;/em&gt;). Any change is attributable to random fluctuations (e.g., one fan spills some of their beer, maybe another fan sees an amusing picture of a cat on their phone). When a basket &lt;em&gt;is&lt;/em&gt; scored, this causes a temporary fluctuation away from the attractor state, after which people resort back to their attractor. More gradual situational factors result in small changes in attractors too. This is why arousal tends to increase with closer games and when the game is approaching the end.&lt;/p&gt;
&lt;div id=&#34;detailed-aspects-of-simulation-and-code&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Detailed Aspects of Simulation and Code&lt;/h3&gt;
&lt;p&gt;There are two parts to this simulation. Part 1 simulates a basketball game for a specified duration of time (&lt;em&gt;n_seconds&lt;/em&gt;) and specified probabilities of scoring. The simulation is also designed with a small post game period - sort of like a cool down after the game. During the post game, fans’ arousal returns to baseline.&lt;/p&gt;
&lt;p&gt;The second and more complicated part of the simulation is the emotional part. Each fan has a score on valence and arousal at each second. These can be further broken down into fixed effects and random effects. The fixed effect for valence is described as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[Valence = 3 + \beta_{1overall.difference}(.20) + \beta_{2recent.score(1.5 + \frac{current.time}{total.time})} - \beta_{3recent.enemy.score}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The fixed effect for arousal looks like this:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[Arousal = 3 + \beta_{1 (\frac{current.time}{total.time})(.75)(post.game)} + \beta_{2(1 - \sqrt{|difference|})} + \beta_{3|recent.basket|}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The exact values for these coefficients are somewhat arbitrary. They resulted from a lot of trial and error to identify which best simulated emotion dynamics.&lt;/p&gt;
&lt;p&gt;Each fan’s valence and arousal is calculated using the above equations + variability. The variability is added by applying random variation to the first constant in the above equations and white noise with a simulated ARIMA model. On top of this, I used a kernel regression smoother to smooth out each fan’s trajectory. To simulate delayed reaction time to baskets, I added some &lt;em&gt;lags&lt;/em&gt; at random intervals - otherwise the simulated fans appear to react quicker than the score board. Here’s what all of this looks like for one fan’s valence over time:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

game_long %&amp;gt;%
  filter(fan == 1,
         team == &amp;quot;team1&amp;quot;) %&amp;gt;%
  ggplot(aes(x = second, y = valence)) +
  geom_line(color = &amp;quot;red&amp;quot;, size = 1) +
  theme_minimal(base_size = 16) +
  labs(title = &amp;quot;Fan One&amp;#39;s Valence over Time&amp;quot;,
       x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Valence&amp;quot;) +
  theme(legend.position = &amp;quot;none&amp;quot;,
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        plot.title = element_text(size = 18, hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/basketball_sim/Basketball_Simulation_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can see this across all fans as well:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;game_long %&amp;gt;%
  ggplot(aes(x = instance, color = team)) +
  geom_line(aes(y = valence), alpha = .65) +
  labs(title = &amp;quot;Valence over Time&amp;quot;,
       x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Valence&amp;quot;) +
  theme_minimal() +
  theme(legend.position = &amp;quot;none&amp;quot;,
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        plot.title = element_text(size = 18, hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/basketball_sim/Basketball_Simulation_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And for arousal…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;game_long %&amp;gt;%
  ggplot(aes(x = instance, color = team)) +
  geom_line(aes(y = arousal), alpha = .65) +
  labs(title = &amp;quot;Arousal over Time&amp;quot;,
       x = &amp;quot;Time&amp;quot;,
       y = &amp;quot;Arousal&amp;quot;) +
  theme_minimal() +
  theme(legend.position = &amp;quot;none&amp;quot;,
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        plot.title = element_text(size = 18, hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/basketball_sim/Basketball_Simulation_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For those interested, here’s the full code for the simulation and first animation. Have fun with it! I’m also looking for ways to improve it. Ironically, I don’t watch a ton of sports, so if you think I’m open to input on how to make it more realistic!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(forecast)
library(gganimate)
library(extrafont)

game_simulation &amp;lt;- function(n_seconds = 1000, n_fans = 25, team1_prob = 0.012, team2_prob = 0.012) {
  
  score_board &amp;lt;- data.frame(matrix(nrow = n_seconds, ncol = 5))
  colnames(score_board) &amp;lt;- c(&amp;quot;second&amp;quot;, &amp;quot;team1_score&amp;quot;, &amp;quot;team2_score&amp;quot;, &amp;quot;difference&amp;quot;, &amp;quot;end_game&amp;quot;)
  score_board$second &amp;lt;- c(1:n_seconds)
  
  score_board$team1_score &amp;lt;- cumsum(sample(c(0, 1, 1.5), n_seconds, replace = TRUE, prob = c(1 - team1_prob, team1_prob * .90, team1_prob * .10)))
  
  score_board$team2_score &amp;lt;- cumsum(sample(c(0, 1, 1.5), n_seconds, replace = TRUE, prob = c(1 - team2_prob, team2_prob * .90, team2_prob * .10)))
  
  score_board$difference &amp;lt;- score_board$team1_score - score_board$team2_score
  
  score_board$end_game = 1
  
  total_time &amp;lt;- n_seconds + n_seconds * .05
  
  end_time &amp;lt;- data.frame(max(score_board$second + 1):(total_time))
  colnames(end_time) &amp;lt;- &amp;quot;second&amp;quot;
  end_state &amp;lt;- score_board[nrow(score_board), 2:5]
  post_game &amp;lt;- data.frame(matrix(nrow = n_seconds * .05, ncol = 0),
                          &amp;quot;team1_score&amp;quot; = end_state$team1_score,
                          &amp;quot;team2_score&amp;quot; = end_state$team2_score,
                          &amp;quot;difference&amp;quot; = end_state$difference,
                          &amp;quot;end_game&amp;quot; = 0)
  
  post_game &amp;lt;- cbind(end_time, post_game)
  
  score_board &amp;lt;- rbind(score_board, post_game)
  
  valence &amp;lt;- function(time, overall_difference, recent_team_score, recent_enemy_score) (
    (overall_difference * .20) + (recent_team_score * (1.5 + time/length(time))) - (recent_enemy_score)
  )
  
  arousal &amp;lt;- function(time, difference, recent_score, end_game) (
    ((time/n_seconds) * .75 * end_game) + (1 - sqrt(abs(difference))) + abs(recent_score * 1.5)
  )
  
  team1_valence &amp;lt;- data.frame(matrix(nrow = total_time, ncol = 0))
  team1_arousal &amp;lt;- data.frame(matrix(nrow = total_time, ncol = 0))
  team2_valence &amp;lt;- data.frame(matrix(nrow = total_time, ncol = 0))
  team2_arousal &amp;lt;- data.frame(matrix(nrow = total_time, ncol = 0))
  
  for(i in 1:n_fans) {

    team1_valence[[i]] &amp;lt;- ksmooth(x = score_board$second,
                                  y = rnorm(n = 1, mean = 3, sd = .25) + (arima.sim(list(order = c(1, 0, 1), ma = -.1, ar = c(.9)), n = total_time) * .25) + valence(time = score_board$second,
                                  overall_difference = score_board$difference,
                                  recent_team_score = lag(score_board$team1_score, n = sample(c(1:5), 1), default = 0) - lag(score_board$team1_score, n = sample(c(6:8), 1), default = 0),
                                  recent_enemy_score = lag(score_board$team2_score, n = sample(c(1:5), 1), default = 0) - lag(score_board$team2_score, n = sample(c(6:8), 1), default = 0)),
                                  bandwidth = total_time/100, kernel = &amp;quot;normal&amp;quot;)$y
    
  }
  
  colnames(team1_valence) &amp;lt;- paste0(&amp;quot;team1_&amp;quot;, &amp;quot;valence_&amp;quot;, 1:n_fans)
  team1_valence[team1_valence &amp;gt; 6] &amp;lt;- 6
  team1_valence[team1_valence &amp;lt; 0] &amp;lt;- 0
  
  for(i in 1:n_fans) {
    team1_arousal[[i]] &amp;lt;- ksmooth(x = score_board$second,
                                  y = rnorm(n = 1, mean = 3, sd = .25) + (arima.sim(list(order = c(1, 0, 1), ma = -.1, ar = c(.9)), n = total_time) * .25) + arousal(time = score_board$second,
                                  difference = score_board$difference,
                                  recent_score = lag(score_board$difference, n = sample(c(1:3), 1), default = 0) - lag(score_board$difference, n = sample(c(4:6), 1), default = 0),
                                  end_game = score_board$end_game),
                                  bandwidth = total_time/100, kernel = &amp;quot;normal&amp;quot;)$y
  }
  
  colnames(team1_arousal) &amp;lt;- paste0(&amp;quot;team1_&amp;quot;, &amp;quot;arousal_&amp;quot;, 1:n_fans)
  
  team1_arousal[team1_arousal &amp;gt; 6] &amp;lt;- 6
  team1_arousal[team1_arousal &amp;lt; 0] &amp;lt;- 0
   
  for(i in 1:n_fans) {
    team2_valence[[i]] &amp;lt;- ksmooth(x = score_board$second,
                                  y = rnorm(n = 1, mean = 3, sd = .25) + (arima.sim(list(order = c(1, 0, 1), ma = -.1, ar = c(.9)), n = total_time) * .25) + valence(time = score_board$second,
                                  overall_difference = -score_board$difference,
                                  recent_team_score = lag(score_board$team2_score, n = sample(c(1:5), 1), default = 0) - lag(score_board$team2_score, n = sample(c(6:8), 1), default = 0),
                                  recent_enemy_score = lag(score_board$team1_score, n = sample(c(1:5), 1), default = 0) - lag(score_board$team1_score, n = sample(c(6:8), 1), default = 0)),
                                  bandwidth = total_time/100, kernel = &amp;quot;normal&amp;quot;)$y
  }
  
  colnames(team2_valence) &amp;lt;- paste0(&amp;quot;team2_&amp;quot;, &amp;quot;valence_&amp;quot;, 1:n_fans)
  
  team2_valence[team2_valence &amp;gt; 6] &amp;lt;- 6
  team2_valence[team2_valence &amp;lt; 0] &amp;lt;- 0
  
  for (i in 1:n_fans) {
    team2_arousal[[i]] &amp;lt;- ksmooth(x = score_board$second,
                                  y = rnorm(n = 1, mean = 3, sd = .25) + (arima.sim(list(order = c(1, 0, 1), ma = -.1, ar = c(.9)), n = total_time) * .25) + arousal(time = score_board$second,
                                  difference = score_board$difference,
                                  recent_score = lag(score_board$difference, n = sample(c(1:3), 1), default = 0) - lag(score_board$difference, n = sample(c(4:6), 1), default = 0),
                                  end_game = score_board$end_game),
                                  bandwidth = total_time/100, kernel = &amp;quot;normal&amp;quot;)$y
  }
  
  colnames(team2_arousal) &amp;lt;- paste0(&amp;quot;team2_&amp;quot;, &amp;quot;arousal_&amp;quot;, 1:n_fans)
  
  team2_arousal[team2_arousal &amp;gt; 6] &amp;lt;- 6
  team2_arousal[team2_arousal &amp;lt; 0] &amp;lt;- 0
  
  game_affect &amp;lt;- cbind(score_board, team1_valence, team1_arousal, team2_valence, team2_arousal)
  
  return(game_affect)
}

set.seed(060519)

game &amp;lt;- game_simulation(n_seconds = 1000, n_fans = 25)

game_long &amp;lt;- game %&amp;gt;%
  mutate(instance = row_number(),
         team1_score = team1_score * 2,
         team2_score = team2_score * 2) %&amp;gt;%
  select(instance, everything()) %&amp;gt;%
  select(-end_game) %&amp;gt;%
  gather(key = &amp;quot;team&amp;quot;, value = &amp;quot;score&amp;quot;, c(team1_valence_1:length(game))) %&amp;gt;%
  separate(col = team, into = c(&amp;quot;team&amp;quot;, &amp;quot;dimension&amp;quot;, &amp;quot;fan&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  spread(dimension, score)
  
p &amp;lt;- game_long %&amp;gt;%
  ggplot() +
  annotate(&amp;quot;rect&amp;quot;, xmin = 0, xmax = 3, ymin = 0, ymax = 3, alpha = 0.5, fill = &amp;quot;lightblue&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 3, xmax = 6, ymin = 0, ymax = 3, alpha = 0.5, fill = &amp;quot;lightgreen&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 0, xmax = 3, ymin = 3, ymax = 6, alpha = 0.2, fill = &amp;quot;red&amp;quot;) +
  annotate(&amp;quot;rect&amp;quot;, xmin = 3, xmax = 6, ymin = 3, ymax = 6, alpha = 0.2, fill = &amp;quot;yellow&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = c(1.5, 4.5, 1.5, 4.5), y = c(1.5, 1.5, 4.5, 4.5), label = c(&amp;quot;Disappointed&amp;quot;, &amp;quot;Content&amp;quot;, &amp;quot;Nervous&amp;quot;, &amp;quot;Excited&amp;quot;),
           size = 10, alpha = .50, family = &amp;quot;Verdana&amp;quot;) +
  geom_text(aes(x = 1.5, y = 5.5, label = paste(&amp;quot;Red:&amp;quot;, team1_score)), size = 8, color = &amp;quot;red&amp;quot;, family = &amp;quot;Verdana&amp;quot;) +
  geom_text(aes(x = 4.5, y = 5.5, label = paste(&amp;quot;Blue:&amp;quot;, team2_score)), size = 8, color = &amp;quot;blue&amp;quot;, family = &amp;quot;Verdana&amp;quot;) +
  geom_point(aes(x = valence, y = arousal, color = team), alpha = .70, size = 4) +
  scale_x_continuous(limits = c(0, 6)) +
  scale_y_continuous(limits = c(0, 6)) +
  scale_color_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;)) +
  labs(title = &amp;#39;Time: {round((max(game_long$second) - frame_time)/60, 2)}&amp;#39;,
       x = &amp;quot;Happiness&amp;quot;,
       y = &amp;quot;Nerves&amp;quot;) +
  theme_minimal(base_size = 16) +
  transition_time(second) +
  theme(legend.position = &amp;quot;none&amp;quot;,
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        plot.title = element_text(size = 18, hjust = .5),
        text = element_text(family = &amp;quot;Verdana&amp;quot;))

game1 &amp;lt;- animate(p, nframes = 1062, width = 500, height = 500, fps = 14, end_pause = 12)

game1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;Kuppens P, Verduyn P. (2017). Emotion dynamics. &lt;em&gt;Current Opinion in Psychology. 17&lt;/em&gt;, 22–26. doi: 10.1016/j.copsyc.2017.06.004.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      
            <category>R</category>
      
            <category>Emotion Dynamics</category>
      
            <category>Simulation</category>
      
      
            <category>R</category>
      
            <category>Emotion Dynamics</category>
      
            <category>Simulation</category>
      
    </item>
    
  </channel>
</rss>
